// halfact.js: contains an ad-hoc, informally-specified, bug-ridden, slow
// implementation of half of React, written by somebody who never learned
// React.

// Uses JavaScript template literals for templating, with some code to let you
// break into DOMNodes in the middle of template text by emitting placeholders
// and cramming the real elements in later.

const timers = require('timers')

// Internal counter to generate unique IDs
let nextId = 0

// Return a string to be added to the DOM. When the string is added to the
// DOM on the current JS tick, it will be replaced with the DOM node passed
// to this function (or the node generated by the function passed to this
// function) on the next tick.  Hacky DOM node embedding for template literals,
// so events can come along.  TODO: Maybe we should just port this whole thing
// to React or something.
function placeDomNode(node) {
  if (node instanceof Function) {
    // Invoke the code (so the user doesn't have to create and invoke a lambda
    // to cram code into an expression
    node = node()
  }

  // Come up with a unique HTML ID for the element we will return.
  let id = 'halfact-placeDomNode-' + nextId
  nextId++

  timers.setImmediate(() => {
    // On the next tick, after our text is in the DOM...

    // Find it
    let waiting = document.getElementById(id)
    if (waiting) {
      // Put the actual DOM node we want to embed before it
      waiting.parentNode.insertBefore(node, waiting)
      // Remove the placeholder
      waiting.parentNode.removeChild(waiting)
    }
  })

  // Return text to make the element we are going to look for.
  return `<span id="${id}"></span>`

  // TODO: Try an approach with dynamically added script tags instead, in case
  // the element doesn't want to be added quite this tick.  The probelm there
  // is: how do you know it will be added at all, and how long do you keep the
  // DOM node around waiting for the script to run?
}

/// Return some HTML that is the safely HTML-escaped version of the given text,
/// or the return value of the given text-returning function. Only works in
/// places you would put HTML elements; not secure inside the actual <> of an
/// HTML tag.
function placeText(text) {
  if (text instanceof Function) {
    // Evaluate function arguments
    text = text()
  }

  // The only good way to do this is to make some fake DOM nodes.
  // See https://stackoverflow.com/a/5251551
  
  let parent = document.createElement('div')
  parent.innerText = text
  return parent.innerHTML
}

/// Make a number fixed precision, with commas
function formatNumber(number) {
  if (number === null) {
    // This property is not applicable for this thing
    return 'N/A'
  }
  if (number > 0.01) {
    // It is big enough to do 2 digits.
    return parseFloat(number.toFixed(2)).toLocaleString()
  } else {
    // Go out to 4 digits, for some really dim luminosities
    return number.toFixed(4)
  }
}

/// Given a number and two corresponding lists of unit names and values, find
/// the best unit and return a string of the number expressed in the best unit.
function formatWithUnits(number, unitNames, unitValues) {
  if (number === null) {
    // This property is not applicable for this thing
    return 'N/A'
  }
  
  let bestIndex = 0
  let bestBadness = 99999

  if (number != 0) {
    // If 0, just use that first unit
    for (let index = 0; index < unitValues.length; index++) {
      // We just use exhaustive search
      let inUnit = number / unitValues[index]
      // The larger the absolute value of the logarithm, the less 1-y the number is
      let badness = Math.abs(Math.log(inUnit))
      if (badness < bestBadness) {
        // New winner!
        bestIndex = index
        bestBadness = badness
      }
    }
  }
  // Format in the given unit
  return formatNumber(number / unitValues[bestIndex]) + ' ' + unitNames[bestIndex]
  
}

module.exports = { placeDomNode, placeText, formatNumber, formatWithUnits }
